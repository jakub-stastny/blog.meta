* About

Meta-repository explaining my blog architecture, decisions and linking related repositories.

This repository itself does not contain any code, but rather serves as a wiki to all the related repositories.

* Components

** Repository [[https://github.com/jakub-stastny/blog.engine][blog.engine]]

This is the actual blog engine written in Elm and Elm UI.

It serves generated blog posts from the [[https://github.com/jakub-stastny/data.blog][data.blog]] repository.

** Repository [[https://github.com/jakub-stastny/blog.parser.post.org][blog.parser.post.org]]
** Repository [[https://github.com/jakub-stastny/blog.parser.post.json][blog.parser.post.json]]
** Repository [[https://github.com/jakub-stastny/blog.generator][blog.generator]]
** Repository [[https://github.com/jakub-stastny/data.blog][data.blog]]

Contains blog posts written in the Org mode format (in the =posts= directory) as well as [[https://github.com/jakub-stastny/blog.generator][blog.generator]]-generated JSON files for the [[https://github.com/jakub-stastny/blog.engine][blog.engine]] (in the =output= directory).

** Repository [[https://github.com/jakub-stastny/blog.custom-elements.org][blog.custom-elements.org]]

Provides =org-mode= [[https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements][custom element]], which allows us to display Org mode formatted text as HTML.

Org mode format is used in the =body= field of the generated blog posts.

It uses [[https://github.com/jakub-stastny/blog.parser.post.org][blog.parser.post.org]] compiled to WebAssembly in order to have a consistent parser output (by using different Org mode parsers we might run into incompatibilities, which is undesirable).

Custom elements can be [[https://guide.elm-lang.org/interop/custom_elements.html][integrated into Elm]], which is how we make use of this in the [[https://github.com/jakub-stastny/blog.engine][blog.engine]].

*** Example

#+BEGIN_SRC html
<article>
  <h1>Hello world!</h1>
  <p class="excerpt">
    Let's blog again!
  </p>

  <org-mode>
    * So what is it going to be about?

    - Programming.
    - Life.
  </org-mode>
#+END_SRC

* Project management

This is the only repository that has GitHub issues enabled. If you want to raise an issue related to any of these projects, please do so here.

* Goals
** Learning and exploring

Let's clarify what I'm trying to achieve here, since things could certainly be done simpler.

For me however, this is more about *learning* than about practicality. I want to learn Elm, Rust, play out with WebAssembly and custom elements and I want to explore [[./doc/literate-programming.org][literate programming]] in depth.

At the same time it's a *proof of concept:* I want to see how easy and practical is it to glue components written in different languages together using WebAssembly.

** Practical application

With all that said, the project is also meant to be /actually useful/, at least for my little site.

In that regard what's most important to me is *no surprises*.

*** Runtime errors

I liked JavaScript before it was cool to like it. And for that reason I always ended up debugging incompatibilities in IE 6 and let me tell you, it wasn't much fun.

So runtime errors are something I really dislike and especially on the front-end. So when Elm came out and says /"let there be no runtime errors"/, I was totally sold on it.

*** Data consistency

But I went much further. Data manipulation is done exclusively by [[https://github.com/jakub-stastny/blog.parser.post.json][blog.parser.post.json]]. There's no /"it's just a simple JSON, let's just parse it"/. It's all done by this package and the rest of the ecosystem calls it for both serialisation and deserialisation.

When [[https://github.com/jakub-stastny/blog.generator][blog.generator]] runs, it will ask the running front-end what version of [[https://github.com/jakub-stastny/blog.parser.post.json][blog.parser.post.json]] does it run. It will only proceed if it's running a compatible version (Elm does semantic versioning automatically, so we can't be wrong).

And finally we use the same Org mode parser throughout the ecosystem. If a post was successfully parsed in the generation phase, it must be successfully parsed on the front-end as well.
